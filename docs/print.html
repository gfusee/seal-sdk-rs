<!--
  Copyright 2025 Quentin Diebold

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Seal Rust SDK Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Developer guide and reference for the seal-sdk-rs crate">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Seal Rust SDK Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>seal-sdk-rs</code> gives you a Seal client that works with any Sui framework. The
crate focuses on developer experience. It ships safe defaults, but you can
replace every layer: HTTP transport, Sui client, signer, and cache. Use the
full <code>sui_sdk</code> stack or a lighter experimental client. The API stays simple so
you can control how requests are built, signed, cached, and executed.</p>
<p>Key features:</p>
<ul>
<li><strong>Modular design</strong>: <code>BaseSealClient</code> accepts generic types for the HTTP
client, Sui RPC adapter, caches, and error types. You can mix and match
implementations without forking the crate.</li>
<li><strong>Helpful defaults</strong>: The provided <code>SealClient</code> variants combine
<code>sui_sdk::SuiClient</code>, <code>reqwest</code>, and different cache strategies (including
<code>moka</code>) so most projects can start quickly.</li>
<li><strong>Parallel performance</strong>: Batch helpers such as <code>encrypt_multiple_bytes</code>
reuse fetched metadata and run remote calls in parallel when possible. This
keeps round trips to Mysten key servers short.</li>
<li><strong>Friendly helpers</strong>: Conversion traits, generic object IDs/addresses, and
BCS serializers simplify data handling. Advanced users can still manage
serialization manually when they need to.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This guide uses the crate with the default features. In this mode the
<code>SealClient</code> specialization is active, combining <code>sui_sdk::SuiClient</code>,
<code>reqwest</code>, and the no-op cache adapters.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>Add the crate to your project:</p>
<pre><code class="language-toml">[dependencies]
seal-sdk-rs = { git = "https://github.com/gfusee/seal-sdk-rs", tag = "0.0.1" }
</code></pre>
<blockquote>
<p><strong>Info:</strong> The examples build a <code>WalletContext</code> from a normal Sui CLI config
(<code>WalletContext::new("&lt;path to the config file&gt;")</code>). This approach is easy, but
not required. Any signer that implements the crate's <code>Signer</code> trait can call
<code>SessionKey::new</code>, so you can bring your own signing logic if you prefer.</p>
</blockquote>
<h2 id="example-setup"><a class="header" href="#example-setup">Example setup</a></h2>
<p>The snippets follow the flow of the integration tests with fewer moving parts.
Both examples rely on the same inputs:</p>
<ul>
<li>One key server identified by <code>setup.key_server_id</code>.</li>
<li>A Seal package deployed at <code>setup.approve_package_id</code>.</li>
<li>A wallet context that can sign personal messages.</li>
</ul>
<p>All helpers return <code>Result&lt;_, SealClientError&gt;</code>, so the <code>?</code> operator propagates
any failure.</p>
<h3 id="encrypting-a-string"><a class="header" href="#encrypting-a-string">Encrypting a string</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use seal_sdk_rs::error::SealClientError;
use seal_sdk_rs::native_sui_sdk::client::seal_client::SealClient;
use sui_sdk::SuiClientBuilder;

struct DemoSetup {
    approve_package_id: seal_sdk_rs::generic_types::ObjectID,
    key_server_id: seal_sdk_rs::generic_types::ObjectID,
}

async fn encrypt_message(
    setup: &amp;DemoSetup,
) -&gt; Result&lt;seal_sdk_rs::crypto::EncryptedObject, SealClientError&gt; {
    let sui_client = SuiClientBuilder::default()
        .build("https://fullnode.testnet.sui.io:443")
        .await?;

    let client = SealClient::new(sui_client);
    let (encrypted, recovery_key) = client
        .encrypt_bytes(
            setup.approve_package_id,
            b"my_id".to_vec(),
            1,
            vec![setup.key_server_id],
            b"hello from seal".to_vec(),
        )
        .await?;

    drop(recovery_key);
    Ok(encrypted)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="decrypting-the-ciphertext"><a class="header" href="#decrypting-the-ciphertext">Decrypting the ciphertext</a></h3>
<p>Assume the package at <code>setup.approve_package_id</code> contains a <code>wildcard</code> module
with a <code>seal_approve</code> function that approves requests for <code>my_id</code>. Use the
<code>EncryptedObject</code> returned by <code>encrypt_message</code> to rebuild the approval
transaction and recover the original string.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use seal_sdk_rs::error::SealClientError;
use seal_sdk_rs::native_sui_sdk::client::seal_client::SealClient;
use seal_sdk_rs::session_key::SessionKey;
use sui_sdk::SuiClientBuilder;
use sui_sdk::wallet_context::WalletContext;
use sui_types::Identifier;
use sui_types::programmable_transaction_builder::ProgrammableTransactionBuilder;
use std::str::FromStr;

struct DemoSetup {
    approve_package_id: seal_sdk_rs::generic_types::ObjectID,
    key_server_id: seal_sdk_rs::generic_types::ObjectID,
}

async fn decrypt_message(
    setup: &amp;DemoSetup,
    encrypted: seal_sdk_rs::crypto::EncryptedObject,
) -&gt; Result&lt;(), SealClientError&gt; {
    let sui_client = SuiClientBuilder::default()
        .build("https://fullnode.testnet.sui.io:443")
        .await?;
    let client = SealClient::new(sui_client);

    let mut wallet = WalletContext::new("&lt;path to the config file&gt;").unwrap();
    let session_key = SessionKey::new(
        setup.approve_package_id,
        5,
        &amp;mut wallet,
    )
    .await?;

    let mut builder = ProgrammableTransactionBuilder::new();
    let id_arg = builder.pure(b"my_id".to_vec())?;
    builder.programmable_move_call(
        setup.approve_package_id.into(),
        Identifier::from_str("wildcard")?,
        Identifier::from_str("seal_approve")?,
        vec![],
        vec![id_arg],
    );
    let approve_ptb = builder.finish();

    let plaintext = client
        .decrypt_object_bytes(
            &amp;bcs::to_bytes(&amp;encrypted)?,
            approve_ptb,
            &amp;session_key,
        )
        .await?;

    assert_eq!(plaintext, b"hello from seal");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts--architecture"><a class="header" href="#concepts--architecture">Concepts &amp; Architecture</a></h1>
<p>This chapter explains how the SDK fits together: what powers <code>BaseSealClient</code>,
how the ready-made specializations behave, and which operational details matter
when you run the client in production.</p>
<h2 id="basesealclient"><a class="header" href="#basesealclient">BaseSealClient</a></h2>
<p><code>BaseSealClient</code> (see <code>src/base_client.rs</code>) is the generic core. It exposes six
type parameters that let you decide which pieces to plug in:</p>
<ul>
<li>key-server info cache implementation</li>
<li>derived-keys cache implementation</li>
<li>Sui RPC error type</li>
<li>Sui client implementation</li>
<li>HTTP error type</li>
<li>HTTP client implementation</li>
</ul>
<p>You can supply any types that implement the required traits:</p>
<ul>
<li><a href="../../src/cache.rs"><code>SealCache</code></a> defines a simple async cache API.</li>
<li><a href="../../src/sui_client.rs"><code>SuiClient</code></a> outlines the Sui RPC calls the client
needs.</li>
<li><a href="../../src/http_client.rs"><code>HttpClient</code></a> asks for a single <code>post</code> method to
talk to Seal key servers.</li>
</ul>
<p>Because the generics stay abstract, you can swap components without editing the
rest of the crate—use a mock HTTP client in tests, replace the cache with a
shared service, or point to a different Sui SDK version.</p>
<h2 id="specializations"><a class="header" href="#specializations">Specializations</a></h2>
<p><code>src/native_sui_sdk/client</code> offers ready-to-use type aliases:</p>
<ul>
<li><strong><code>SealClient</code></strong> uses <code>sui_sdk::SuiClient</code>, <code>reqwest::Client</code>, and the <code>NoCache</code>
adapters. The <code>client</code> and <code>native-sui-sdk</code> features enable it by default.</li>
<li><strong><code>SealClientLeakingCache</code></strong> adds <code>Arc&lt;Mutex&lt;HashMap&lt;...&gt;&gt;&gt;</code> caches. These
caches never evict, so use them only for short-lived tools.</li>
<li><strong><code>SealClientMokaCache</code></strong> (behind the <code>moka-client</code> feature) relies on
<code>moka::future::Cache</code>, giving you configurable eviction for long-lived
services.</li>
</ul>
<p>If you need something else, create your own alias that wires the right HTTP
client, Sui client, and caches into <code>BaseSealClient</code>.</p>
<h2 id="caching-strategies"><a class="header" href="#caching-strategies">Caching strategies</a></h2>
<p>Caching is optional but useful. The client can cache two kinds of data:</p>
<ul>
<li>key-server metadata fetched from Sui</li>
<li>derived keys fetched from the Seal servers</li>
</ul>
<p><code>NoCache</code> skips caching. The <code>HashMap</code> and <code>moka</code> adapters show how to keep
results in memory. To integrate a different cache (Redis, a database, etc.),
implement <code>SealCache</code>.</p>
<h2 id="session-keys-jwt-analogy"><a class="header" href="#session-keys-jwt-analogy">Session keys (JWT analogy)</a></h2>
<p><code>SessionKey</code> lives in <code>src/session_key.rs</code>. Instead of signing every decrypt
request with a wallet, you sign once to mint a short-lived key. Think of it like
a JWT:</p>
<ol>
<li>A signer that implements <code>Signer</code> creates the session key.</li>
<li>During the TTL window, decrypt calls use that key without asking the wallet
again.</li>
</ol>
<p>Handle the session key like a bearer token: keep it safe in memory and drop it
when you no longer need it.</p>
<h2 id="recovery-keys-and-operational-security"><a class="header" href="#recovery-keys-and-operational-security">Recovery keys and operational security</a></h2>
<p>Every encrypt helper returns <code>(EncryptedObject, [u8; 32])</code>. The second value is
an emergency recovery key. Store it if you want a break-glass option when key
servers go offline. Drop it if you never want a single authority to decrypt all
payloads without the key-server quorum.</p>
<h2 id="supported-sui-sdks-and-bridging-types"><a class="header" href="#supported-sui-sdks-and-bridging-types">Supported Sui SDKs and bridging types</a></h2>
<p>Today you can choose between two Sui SDK families:</p>
<ul>
<li><code>MystenLabs/sui</code> is mature but heavy. It pulls in a large dependency graph and
build toolchain.</li>
<li><code>MystenLabs/sui-rust-sdk</code> is lightweight but still experimental.</li>
</ul>
<p><code>seal-sdk-rs</code> already bridges both worlds. <code>src/generic_types.rs</code> defines
<code>ObjectID</code> and <code>SuiAddress</code>, and the
<code>BCSSerializableProgrammableTransaction</code> trait hides differences between the SDKs.
Conversions run in both directions and all types support <code>serde</code>.</p>
<p>The built-in specializations (<code>SealClient</code>, <code>SealClientLeakingCache</code>,
<code>SealClientMokaCache</code>) currently target <code>MystenLabs/sui</code> and use JSON-RPC. gRPC
support is on the roadmap because the JSON-RPC endpoints have started their
phase-out. When the lightweight SDK stabilizes, new specializations can land
without changing the overall design.</p>
<h2 id="feature-flags-overview"><a class="header" href="#feature-flags-overview">Feature flags overview</a></h2>
<p><code>Cargo.toml</code> exposes several public features:</p>
<ul>
<li><code>default</code> = <code>client</code>, <code>native-tls</code>, <code>native-sui-sdk</code></li>
<li><code>client</code> enables the HTTP layer (<code>reqwest</code> + <code>http</code>).</li>
<li><code>native-tls</code> switches <code>reqwest</code> to native TLS. Disable it if you want to opt
into <code>rustls</code> manually.</li>
<li><code>native-sui-sdk</code> pulls in <code>sui_sdk</code>, <code>sui_types</code>, <code>sui_keys</code>, and
<code>shared_crypto</code>, plus the Sui-specific adapters.</li>
<li><code>moka-client</code> adds the <code>moka</code> cache specialization.</li>
</ul>
<p>Disable the defaults if you want to bring your own implementations and re-enable
only the pieces you need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>This chapter shows how to plug in custom clients, caches, and transports, plus
how to pick the right feature flags and error strategy when you deploy the SDK.</p>
<h2 id="custom-sui-client"><a class="header" href="#custom-sui-client">Custom Sui client</a></h2>
<p>You can run <code>BaseSealClient</code> with a different version of the Sui SDK. Implement
the <a href="../../src/sui_client.rs"><code>SuiClient</code></a> trait for the client type you want to
use and update your <code>Cargo.toml</code> to point at that version. The snippet below is
based on the default implementation for <code>sui_sdk::SuiClient</code> and can serve as a
starting point:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use seal_sdk_rs::base_client::KeyServerInfo;
use seal_sdk_rs::generic_types::ObjectID;
use seal_sdk_rs::sui_client::SuiClient;
use async_trait::async_trait;
use serde_json::Value;
use sui_sdk::rpc_types::{SuiMoveValue, SuiParsedData};
use sui_types::TypeTag;
use sui_types::dynamic_field::DynamicFieldName;

#[derive(Debug, thiserror::Error)]
pub enum CustomSuiError {
    #[error("Sui SDK error: {0}")]
    SuiSdk(#[from] sui_sdk::error::Error),
    #[error("Missing object data for {object_id}")]
    Missing { object_id: sui_types::base_types::ObjectID },
    #[error("Unexpected data shape for {object_id}")]
    Invalid { object_id: sui_types::base_types::ObjectID },
}

#[async_trait]
impl SuiClient for sui_sdk::SuiClient {
    type Error = CustomSuiError;

    async fn get_key_server_info(
        &amp;self,
        key_server_id: [u8; 32],
    ) -&gt; Result&lt;KeyServerInfo, Self::Error&gt; {
        let key_server_id = sui_types::base_types::ObjectID::new(key_server_id);
        let response = self
            .read_api()
            .get_dynamic_field_object(
                key_server_id,
                DynamicFieldName {
                    type_: TypeTag::U64,
                    value: Value::String("1".to_string()),
                },
            )
            .await?;

        let object_data = response.data.ok_or(CustomSuiError::Missing { object_id: key_server_id })?;
        let content = object_data.content.ok_or(CustomSuiError::Missing { object_id: key_server_id })?;

        let parsed = match content {
            SuiParsedData::MoveObject(obj) =&gt; obj,
            _ =&gt; return Err(CustomSuiError::Invalid { object_id: key_server_id }),
        };

        let value_struct = match parsed.fields.field_value("value") {
            Some(SuiMoveValue::Struct(s)) =&gt; s,
            _ =&gt; return Err(CustomSuiError::Invalid { object_id: key_server_id }),
        };

        let url = match value_struct.field_value("url") {
            Some(SuiMoveValue::String(url)) =&gt; url,
            _ =&gt; return Err(CustomSuiError::Invalid { object_id: key_server_id }),
        };

        let name = match value_struct.field_value("name") {
            Some(SuiMoveValue::String(name)) =&gt; name,
            _ =&gt; return Err(CustomSuiError::Invalid { object_id: key_server_id }),
        };

        let public_key_bytes = match value_struct.field_value("pk") {
            Some(SuiMoveValue::Vector(bytes)) =&gt; bytes
                .into_iter()
                .map(|value| match value {
                    SuiMoveValue::Number(byte) =&gt; u8::try_from(byte).map_err(|_| CustomSuiError::Invalid { object_id: key_server_id }),
                    _ =&gt; Err(CustomSuiError::Invalid { object_id: key_server_id }),
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?,
            _ =&gt; return Err(CustomSuiError::Invalid { object_id: key_server_id }),
        };

        Ok(KeyServerInfo {
            object_id: ObjectID(key_server_id.into_bytes()),
            name,
            url,
            public_key: hex::encode(public_key_bytes),
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Compile <code>seal-sdk-rs</code> against your chosen dependency version and the new
implementation becomes active.</p>
<h2 id="custom-http-client"><a class="header" href="#custom-http-client">Custom HTTP client</a></h2>
<p><a href="../../src/http_client.rs"><code>HttpClient</code></a> defines a single method. Implement it
for your preferred transport (hyper, surf, a custom blocking client, etc.):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

async fn post&lt;S: ToString + Send + Sync&gt;(
    &amp;self,
    url: &amp;str,
    headers: HashMap&lt;String, String&gt;,
    body: S,
) -&gt; Result&lt;PostResponse, Self::PostError&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Seal key servers only expect HTTP <code>POST</code> requests, so you do not need anything
else.</p>
<h2 id="custom-caching"><a class="header" href="#custom-caching">Custom caching</a></h2>
<p>To plug in your own cache, implement <a href="../../src/cache.rs"><code>SealCache</code></a>. The key
method, <code>try_get_with</code>, either returns a cached value or runs the provided
future to populate the cache:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::sync::Arc;

async fn try_get_with&lt;Fut, Error&gt;(
    &amp;self,
    key: Self::Key,
    init: Fut,
) -&gt; Result&lt;Self::Value, Arc&lt;Error&gt;&gt;
where
    Fut: Future&lt;Output = Result&lt;Self::Value, Error&gt;&gt; + Send,
    Error: Send + Sync + 'static;
<span class="boring">}</span></code></pre></pre>
<p>Whenever possible, add request coalescing so you collapse duplicate misses into
one in-flight future. This reduces unnecessary parallel calls, keeps you away
from Seal server rate limits, and lightens the load on Sui RPC endpoints.</p>
<h2 id="error-handling-strategies"><a class="header" href="#error-handling-strategies">Error handling strategies</a></h2>
<p>Public helpers return <code>Result&lt;_, SealClientError&gt;</code>. Examples and tests sometimes
use <code>anyhow::Result&lt;_&gt;</code>. Both styles support the <code>?</code> operator, so you can bubble
errors up or wrap them in your own enums for richer diagnostics.</p>
<h2 id="deployment-considerations"><a class="header" href="#deployment-considerations">Deployment considerations</a></h2>
<ul>
<li><strong>Feature gating</strong>: Disable the default feature set when you want a custom
stack, then re-enable only what you need (for example,
<code>--no-default-features --features client,moka-client</code>).</li>
<li><strong>Parallel behavior</strong>: Encrypt and decrypt helpers send requests in parallel.
Keep an eye on quotas for key servers and Sui RPC. Caches plus coalescing help
control the traffic.</li>
<li><strong>Recovery keys</strong>: Decide whether to store the <code>[u8; 32]</code> recovery key that
encrypt helpers return. Dropping it removes a potential backdoor. Storing it
gives you an emergency path if key servers become unavailable.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
